#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <stdbool.h>
#include <string.h>
#include <sys/poll.h>
#include <signal.h>
#include <fcntl.h>
#define _GNU_SOURCE
#include <unistd.h>

#define maxBufferX 1024
#define maxBufferY 1024
#define maxFileBuffer 5
#define maxBufferCommand 20

int counter = 0;

// https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html

// https://github.com/mcandre/charm/blob/master/lib/charm.c

/*Use this variable to remember original terminal attributes. */

struct termios saved_attributes;
struct winsize window;

int selection_status = 0;
int selection_status_x = 0;
int selection_status_y = 0;
int selection_start_x = 0;
int selection_start_y = 0;
int selection_end_x = 0;
int selection_end_y = 0;



struct pollfd fds[2];
nfds_t nfds = 2;	//Number of fds of poll
int ret;

const char *mouse = "/dev/input/mice";

int mX = 0, mY = 0; //Mouse cursor relatif
int mouseCursorX, mouseCursorY; //Mouse cursor absolute
int cursorX = 0, cursorY = 0, currentFile = 0; //Keyboard cursor absolute & current working file
int fileX = 0, fileY = 0; //Position of the file to write from the buffer array
char fileList[maxFileBuffer][100];	//List of file names.
bool commandMode = false, insertionMode = false;

void openFile(char textBufferDisplay[maxFileBuffer][maxBufferX][maxBufferY])
{
	char c;
	FILE * fp;
	fp = fopen(fileList[currentFile], "r");
	int posX = 0, posY = 0;
	c = '0';
	while (c != EOF)
	{
		c = fgetc(fp);
		if(c != EOF)
			textBufferDisplay[currentFile][posX][posY] = c;
		if (c == '\n' || c == EOF)
		{
			posX = 0;
			posY++;
		}
		else
		{
			posX++;
		}
	}	
	fclose(fp);
}

void saveFile(char textBufferDisplay[maxFileBuffer][maxBufferX][maxBufferY])
{
	char c;
	int fp = open (fileList[currentFile], O_WRONLY|O_CREAT|O_TRUNC, 0644);
	for (int posY = 0; posY < maxBufferY; posY++)
	{
		for (int posX = 0; posX < maxBufferX; posX++)
		{
			c = textBufferDisplay[currentFile][posX][posY];
			if(c > 0 && c <= 255 )
				write(fp, &c, 1);
		}
	}
	close(fp);
}

void reset_input_mode(void)
{
	tcsetattr(STDIN_FILENO, TCSANOW, &saved_attributes);
}

void set_input_mode(void)
{
	struct termios tattr;

	/*Make sure stdin is a terminal. */
	if (!isatty(STDIN_FILENO))
	{
		fprintf(stderr, "Not a terminal.\n");
		exit(EXIT_FAILURE);
	}

	/*Save the terminal attributes so we can restore them later. */
	tcgetattr(STDIN_FILENO, &saved_attributes);
	atexit(reset_input_mode);

	/*Set the funny terminal modes. */
	tcgetattr(STDIN_FILENO, &tattr);
	//tattr.c_iflag &= ~(IGNCR | INLCR);
	tattr.c_lflag &= ~(ICANON | ECHO | FLUSHO); /*Clear ICANON, ECHO and FLUSHO. */
	tattr.c_cc[VMIN] = 0;
	tattr.c_cc[VTIME] = 0;
	tcsetattr(STDIN_FILENO, TCSANOW, &tattr);
}

char *readCharacter(char *buf)
{
	int i = 0;
	buf[0] = '\0';
	buf[1] = '\0';
	buf[2] = '\0';

	char c = '\0';

	ssize_t n = 0;

	// Read at least one character.
	while (n < 1)
	{
		n = read(fileno(stdin), &c, 1);
	}

	while (i < 3 && n > 0)
	{
		buf[i++] = c;
		n = read(fileno(stdin), &c, 1);
	}
	return buf;
}

void move(int x, int y)
{
	cursorX = x;
	cursorY = y;
	y++;
	x++;
	char dest[150] = "";
	//Write the bottom bar, dim the text, invert the color, write Location of cursor, remove inversion & dim
	sprintf(dest, "\x1b[2m\x1b[7m\x1b[%d;%dH %s Loc: %d,%d   \x1b[0m\x1b[27m\x1b[%d;%dH", window.ws_row, window.ws_col - 35, insertionMode?"Insert":"Normal" ,fileX + cursorX, fileY + cursorY, y, x);
	write(STDOUT_FILENO, dest, sizeof(dest));
	fflush(stdout);
}

void clear(void)
{
	write(STDOUT_FILENO, "\x1b[2J\x1b[1;1H", 16);
	fflush(stdout);
}

void writeBuffer(char textBufferDisplay[maxFileBuffer][maxBufferX][maxBufferY], int fileOriginX, int fileOriginY, int setCursorX, int setCursorY)
{
	mouseCursorX=mX;
	mouseCursorY=mY;
	mouseCursorX += fileOriginX;
	mouseCursorY += fileOriginY;
	char dest[150] = "";
	clear();
	move(0, 0);
	char c;
	for (int posY = fileOriginY; posY < window.ws_row + fileOriginY -1; posY++) //Writes buffer starting at position in text ends at position in text + terminal size
	{
		for (int posX = fileOriginX; posX < window.ws_col + fileOriginX; posX++)
		{

			if(selection_status==1) //Text selection
			{
				if(posX==selection_start_x+fileOriginX && posY==selection_start_y+fileOriginY)
				{
					strcpy(dest, "\x1b[7m");
					write(STDOUT_FILENO, dest, sizeof(dest));
				}

				if(posX==selection_end_x+fileOriginX && posY==selection_end_y+fileOriginY)
				{
					strcpy(dest, "\x1b[27m");
					write(STDOUT_FILENO, dest, sizeof(dest));
				}
			}

			if(posX==mouseCursorX && posY==mouseCursorY) //Invert color for mouse cursor
			{
				strcpy(dest, "\x1b[7m");
				write(STDOUT_FILENO, dest, sizeof(dest));
			}

			c = textBufferDisplay[currentFile][posX][posY];
							write(STDOUT_FILENO, &c, sizeof(char));

			if(posX==mouseCursorX && posY==mouseCursorY)
			{	
				strcpy(dest, "\x1b[27m");
				write(STDOUT_FILENO, dest, sizeof(dest));
			}
		}
	}
	move(0,window.ws_row);	
	strcpy(dest, "\x1b[2m\x1b[7m");
	write(STDOUT_FILENO, dest, sizeof(dest));
	for(int posX = 0; posX< window.ws_col; posX++) // Fill bottom bar with blank inverted color 
	{
		c = ' ';
		write(STDOUT_FILENO, &c, sizeof(char));
	}
	move(window.ws_col - strlen(fileList[currentFile]) - 1,window.ws_row);
	if(strlen(fileList[currentFile]) < 18) //Write file name if name fits
		sprintf(dest, "\x1b[2m\x1b[7m%s\x1b[0m",fileList[currentFile]);
	else
		strcpy(dest, "\x1b[2m\x1b[7mFile name too long\x1b[0m");
	write(STDOUT_FILENO, dest, sizeof(dest));
	move(setCursorX, setCursorY);
	fflush(stdout);
}

void search(char textBufferDisplay[maxFileBuffer][maxBufferX][maxBufferY], char word[50], int occurence)
{
	//search for the (n)th occurence of a word. Go through file with word first character, if equality is found then  compare each character of word with text next characters 
	bool found = false;
	for (int posY = 0; posY < maxBufferY; posY++)
	{
		for (int posX = 0; posX < maxBufferX; posX++)
		{
			if(textBufferDisplay[currentFile][posX][posY] == word[0])
			{
				for(int i = 1; i < strlen(word); i++)
				{
					if(textBufferDisplay[currentFile][posX+i][posY] == word[i])
					{
						found = true;
						if(strlen(word) == 1)
						{
							break;
						}
					}
					else
					{
						found = false;
						break;
					}
				}
				if(found == true)
				{
					if(occurence == 1)
					{
						writeBuffer(textBufferDisplay, posX / window.ws_col * window.ws_col, posY / window.ws_row * window.ws_row, posX - (posX / window.ws_col * window.ws_col) + strlen(word), posY - (posY / window.ws_row * window.ws_row));
						return;
					}	
					else
					{
						occurence--;
					}
				}
			}
		}
	}
}

//mouse input function, takes in address of x and y coordinates to modify them and output the clicked button
int mouse_input(char* x_axis, char* y_axis)
{
	unsigned char code[3];	//buffer
	int l_bt = 0, m_bt = 0, r_bt = 0;

    int bytes = read(fds[1].fd, code, sizeof(code));	//parsing of the mouse input

    if(bytes > 0)
    {
        l_bt = code[0] & 0x1;
        r_bt = code[0] & 0x2;
        m_bt = code[0] & 0x4;

        *x_axis = code[1];
        *y_axis = code[2];
    }

    if(l_bt==1)	//left click
    {
        return 1;
    }
    if(m_bt==4)	//middle click
    {
        return 2;
    }
    if(r_bt==2) //right click
    {
        return 3;
    }

    return 0;
}

int main(int argc, char *argv[])
{
	//Keyboard event
	fds[0].fd = STDIN_FILENO;
	fds[0].events = POLLIN;
	//Mouse event
	fds[1].fd = open(mouse, O_RDONLY);
	fds[1].events = POLLIN;

	char textBufferDisplay[maxFileBuffer][maxBufferX][maxBufferY];
	char commandBuffer[maxBufferCommand];

	//Clear texts buffers
	for(int fileZ = 0; fileZ < maxFileBuffer; fileZ++)
	{
		for (int posY = 0; posY < maxBufferY; posY++)
		{
			for (int posX = 0; posX < maxBufferX; posX++)
			{
				textBufferDisplay[currentFile][posX][posY] = '\0';
			}
		}
	}

	ioctl(STDOUT_FILENO, TIOCGWINSZ, &window);
	set_input_mode();


	//Parsing of file names into an array
	if (argc > 1)
	{
		for(int i = 1; i < argc ; i++)
		{
			strcpy(fileList[i - 1],argv[i]);
			openFile(textBufferDisplay);
			currentFile++;
		}
		currentFile = 0;
	}

	writeBuffer(textBufferDisplay, 0, 0, 0, 0);
	
	char *buf = (char*) malloc(3* sizeof(char));
	char dest[50] = "";

	bool exit = false;
	while (!exit)
	{
		//nfds set to 2 events
		ret = poll(fds, nfds, -1);

		if (fds[0].revents&POLLIN)
		{
			buf = readCharacter(buf);
			write(STDOUT_FILENO, &buf[0], sizeof(char));
	
			if (buf[0] == '\x1b' && buf[1] == '\0')	//Esc key
			{
				if(commandMode == true)
				{
					commandMode = false;
					writeBuffer(textBufferDisplay, fileX, fileY, 0, 0);
				}
				else
				{
					insertionMode = false;
					writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
				}
			}
			else if (buf[0] == 'i' && commandMode == false && insertionMode == false)	//i key when in normal mode
			{
				insertionMode = true;
				writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
			}
			else  if (buf[0] == '\x7f' && cursorX >= 0)	//del key
			{
				textBufferDisplay[currentFile][fileX + cursorX -1][fileY + cursorY] = ' ';
				writeBuffer(textBufferDisplay, fileX, fileY, cursorX - 1, cursorY);
			}
			else if (buf[0] == '\n')	//return key
			{
				if(commandMode == false)
				{
					move(0, cursorY + 1);
				}
				else	//read commands after colon
				{
					writeBuffer(textBufferDisplay, fileX, fileY, 0, 0);
					if(commandBuffer[0] == 'q')
					{
						exit = true;
					}
					else if (commandBuffer[0]=='b')		//multiple buffers command implementation
					{
						if(commandBuffer[2]=='n')		//next buffer command
						{
							if(currentFile == maxFileBuffer)
								currentFile = 0;
							else
								currentFile++;
							writeBuffer(textBufferDisplay, 0, 0, 0, 0);
						}
						else if(commandBuffer[2]=='p')		//previous buffer command
						{
							if(currentFile == 0)
								currentFile = maxFileBuffer;
							else
								currentFile--;
							writeBuffer(textBufferDisplay, 0, 0, 0, 0);
						}
					}
					else if (commandBuffer[0]=='w')		//write to file command
					{
						if(commandBuffer[2] != ' ')
						{
							for(int i = 2; commandBuffer[i] != '\0'; i++)
							{
								dest[i-2] = commandBuffer[i];
								dest[i-1] = '\0';
							}
							strcpy(fileList[currentFile],dest);
							saveFile(textBufferDisplay);
						}
						else
						{
							saveFile(textBufferDisplay);
						}
						writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
					}
					else if (commandBuffer[0]=='s')		//search text
					{
						for(int i = 4; commandBuffer[i] != '\0'; i++) //comand second param, word to search
						{
							dest[i-4] = commandBuffer[i];
							dest[i-3] = '\0';
						}
						char numStr[10];
						for(int i = 2; commandBuffer[i] != ' '; i++) //command first param, occurence of word to search for
						{
							numStr[i-2] = commandBuffer[i];
							numStr[i-1] = '\0';
						}
						search(textBufferDisplay, dest, atoi(numStr));
					}
					else if (commandBuffer[0]=='m')		//write to file command
					{
						char xStr[10];
						char yStr[10];
						for(int i = 2; commandBuffer[i] != ' '; i++) //Command first param x value
						{
							xStr[i-2] = commandBuffer[i];
							xStr[i-1] = '\0';
						}
						for(int i = 3+strlen(xStr); commandBuffer[i] != '\0'; i++) //Command second param y value
						{
							yStr[i-3-strlen(xStr)] = commandBuffer[i];
							yStr[i-2-strlen(xStr)] = '\0';
						}
						writeBuffer(textBufferDisplay, atoi(xStr) / window.ws_col * window.ws_col, atoi(yStr) / window.ws_row * window.ws_row, atoi(xStr) - (atoi(xStr) / window.ws_col * window.ws_col), atoi(yStr) - (atoi(yStr) / window.ws_row * window.ws_row));
					}
					commandMode = false;
				}
			}
			else if (buf[0] == ':')	//colon key
			{
				//Goes into commandmode only if in normal mode
				if(commandMode == false && insertionMode == false)
				{
					writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
					commandMode = true;
					move(0,window.ws_row);
					for(int i = 0; i < maxBufferCommand; i++)
					{
						commandBuffer[i] = '\0';
					}
				}
			}
			else if (buf[0] == '\x1b' && buf[2] == 'C')	//Right arrow key
			{
				if(cursorY <= maxBufferX)
				{
					cursorX++;
					move(cursorX, cursorY);
					if(cursorX == window.ws_col)
					{
						fileX += window.ws_col;
						writeBuffer(textBufferDisplay, fileX, fileY, 0, cursorY);
					}
				}
			}
			else if (buf[0] == '\x1b' && buf[2] == 'D' && cursorX > 0)	//Left arrow key
			{
				if(cursorX > 0)
				{
					cursorX--;
					move(cursorX, cursorY);
					if(cursorX <= 0 && fileX > 0)
					{
						fileX -= window.ws_col;
						writeBuffer(textBufferDisplay, fileX, fileY, window.ws_col-1, cursorY);
					}
				}
			}
			else if (buf[0] == '\x1b' && buf[2] == 'A')	//Up arrow key
			{
				if(cursorY > 0 && commandMode == false)
				{
					cursorY--;
					move(cursorX, cursorY);
					if(cursorY <= 0 && fileY > 0)
					{
						fileY -= window.ws_row;
						writeBuffer(textBufferDisplay, fileX, fileY, cursorX, window.ws_row-2);
					}
				}
			}
			else if (buf[0] == '\x1b' && buf[2] == 'B')	//Down arrow key
			{
				if(cursorY <= maxBufferY && commandMode == false)
				{
					cursorY++;
					move(cursorX, cursorY);
					if(cursorY == window.ws_row - 1)
					{
						fileY += window.ws_row;
						writeBuffer(textBufferDisplay, fileX, fileY, cursorX, 0);
					}
				}
			}
			else
			{
				if(cursorY == window.ws_row) // then currently in command line
				{
					commandBuffer[cursorX] = buf[0];
					commandBuffer[cursorX+1] = '\0';
				}
				else
				{
					if(insertionMode == true)
					{
						textBufferDisplay[currentFile][fileX + cursorX][fileY + cursorY] = buf[0];
					}
					else
					{
						writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
						cursorX--;
					}
				}
				cursorX++;
			}
		}

		//Mouse event
		if (fds[1].revents&POLLIN)
		{
			char x=0;
			char y=0;
			int button=0;
    		
			button = mouse_input(&x,&y);	//Stores the pressed button into variable button and modify x and y by the mouse relative movement
				
			//mX and mY accumulates the movement of the cursor and limit their movement to the size of the terminal
			if(counter == 10)
			{
				if((int)x!=0)
				{
					if(mX+x >= 0 && mX+x <= window.ws_col * 2)
					{
						mX = mX+(int)x;
						if(button == 2 && selection_status_x==0)
						{
							selection_status_x = 1;
							selection_status=1;
							selection_start_x=mX;
						}
						if(button == 0 && selection_status == 1)
						{
							selection_end_x=mX;
						}
					}
				}
				if((int)y!=0)
				{
					if(mY-y >= 0 && mY-y <= (window.ws_row-2) * 2)
					{
						mY = mY-y;
						if(button == 2 && selection_status_y==0)
						{
							selection_status_y = 1;
							selection_status=1;
							selection_start_y=mY;
						}
						if(button == 0 && selection_status == 1)
						{
							selection_end_y=mY;
						}
					}
				}
				writeBuffer(textBufferDisplay, fileX, fileY, cursorX, cursorY);
				counter = 0;
			}
			else
				counter++;
				
			if(button == 1 && x==0 && y==0)
			{
				move(mX,mY);	//Moves the vim cursor using the accumulated mouse movement
			}
		}
	}
	move(0, 0);
	clear();
	return EXIT_SUCCESS;
}